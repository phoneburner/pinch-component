<?php

declare(strict_types=1);

namespace PhoneBurner\Pinch\Component\Cryptography\KeyManagement;

use PhoneBurner\Pinch\Component\Cryptography\Asymmetric\EncryptionKeyPair;
use PhoneBurner\Pinch\Component\Cryptography\Asymmetric\EncryptionKeyPairSeed;
use PhoneBurner\Pinch\Component\Cryptography\Asymmetric\SignatureKeyPair;
use PhoneBurner\Pinch\Component\Cryptography\Asymmetric\SignatureKeyPairSeed;
use PhoneBurner\Pinch\Component\Cryptography\Exception\CryptographicLogicException;
use PhoneBurner\Pinch\Component\Cryptography\Symmetric\SharedKey;
use PhoneBurner\Pinch\String\BinaryString\BinaryString;
use PhoneBurner\Pinch\String\BinaryString\PackFormat;

use function PhoneBurner\Pinch\String\bytes;

final readonly class KeyDerivation
{
    /**
     * Use a key or string as the seed for generating a new SharedKey.
     *
     * A new key is generated from the source material using HKDF-Blake2b and the
     * $info parameter. The original key has to have a length greater than zero,
     * though it should be a high-entropy value, such as any of the other 256-bit
     * keys generated by this library. This operation is deterministic, so the
     * same key and info will always generate the same key.
     */
    public static function shared(BinaryString|string $key, string $info = ''): SharedKey
    {
        return new SharedKey(self::hkdf($key, SharedKey::LENGTH, $info));
    }

    /**
     * Use a key or string as the seed for generating a new EncryptionKeyPair.
     *
     * For this operation, an intermediate key is generated from the source material,
     * using HKDF-Blake2b and the $hkdf_info parameter, which is then used as the
     * seed for generating a new X25519 key pair. The original key has to have a
     * length greater than zero, though it should be a high-entropy value, such
     * as any of the other 256-bit keys generated by this library. This operation
     * is deterministic, so the same key and info will always generate the same
     * key pair.
     */
    public static function encryption(BinaryString|string $key, string $hkdf_info = ''): EncryptionKeyPair
    {
        return EncryptionKeyPair::fromSeed(
            new EncryptionKeyPairSeed(self::hkdf($key, EncryptionKeyPairSeed::LENGTH, $hkdf_info)),
        );
    }

    /**
     * Use a key or string as the seed for generating a new SignatureKeyPair.
     *
     * For this operation, an intermediate key is generated from the source material,
     * using HKDF-Blake2b and the $hkdf_info parameter, which is then used as the
     * seed for generating a new Ed25519 key pair. The original key has to have a
     * length greater than zero, though it should be a high-entropy value, such
     * as any of the other 256-bit keys generated by this library. This operation
     * is deterministic, so the same key and info will always generate the same
     * key pair.
     */
    public static function signature(BinaryString|string $key, string $hkdf_info = ''): SignatureKeyPair
    {
        return SignatureKeyPair::fromSeed(
            new SignatureKeyPairSeed(self::hkdf($key, SignatureKeyPairSeed::LENGTH, $hkdf_info)),
        );
    }

    /**
     * HKDF-BLAKE2b
     *
     * A derivative of the HKDF key derivation function that uses the BLAKE2b
     * as the underlying hash function. This is useful when you need to derive
     * multiple keys from a single master key. The HKDF function uses a salt to
     * prevent certain types of attacks, and a context string to differentiate
     * between different uses of the same key. By default, the salt is set to
     * a null-byte string and used as the key for the BLAKE2b hash function.
     *
     * @return non-empty-string the raw binary representation of the derived key
     * @link https://github.com/paragonie/halite/blob/master/src/Util.php for
     * the reference implementation this is based on.
     */
    public static function hkdf(
        BinaryString|string $key,
        int $length = \SODIUM_CRYPTO_GENERICHASH_BYTES,
        string $info = '',
        string|null $salt = null,
    ): string {
        $length > 1 || throw new CryptographicLogicException('HKDF Length Must Be Non-Negative');
        $length <= 8160 || throw new CryptographicLogicException('HKDF Length Cannot Exceed 8160 Bytes');

        // If no salt string is provided, set it to a hash-length string of null bytes
        $salt ??= \str_repeat("\x00", \SODIUM_CRYPTO_GENERICHASH_BYTES);

        // HKDF-Extract
        $prk = \sodium_crypto_generichash(bytes($key), $salt);

        // HKDF-Expand

        // Shortcut the very common case of getting a 256-bit key.
        if ($length === \SODIUM_CRYPTO_GENERICHASH_KEYBYTES) {
            return \sodium_crypto_generichash($info . "\x01", $prk, $length);
        }

        $t = '';
        for ($i = 1, $block = ''; \strlen($t) < $length; ++$i) {
            $block = \sodium_crypto_generichash($block . $info . \pack(PackFormat::CHAR_UNSIGNED, $i), $prk);
            $t .= $block;
        }

        $key = \substr($t, 0, $length);
        \assert(\strlen($key) === $length);

        return $key;
    }
}
